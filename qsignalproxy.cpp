/*
 * QSignalProxy - Proxy funtions for Qt Signal/Slot connections
 * Copyright (C) 2011 Jonas Gehring
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */


#include "qsignalproxy.h"

using namespace QSignalProxyFunctions;


// Reimplemented from QOBJECT macro, normally generated by moc
QT_BEGIN_MOC_NAMESPACE
static const uint qt_meta_data_QSignalProxy[] = {
 // content:
       5,       // revision
       0,       // classname
       0,    0, // classinfo
       0,    0, // methods
       0,    0, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       0,       // signalCount

       0        // eod
};

static const char qt_meta_stringdata_QSignalProxy[] = {
    "QSignalProxy\0"
};

const QMetaObject QSignalProxy::staticMetaObject = {
    { &QObject::staticMetaObject, qt_meta_stringdata_QSignalProxy,
      qt_meta_data_QSignalProxy, 0 }
};


/*! Constructor.
 *
 */
QSignalProxy::QSignalProxy(QObject *parent)
	: QObject(parent)
{

}

/*! Destructor.
 *
 */
QSignalProxy::~QSignalProxy()
{
	qDeleteAll(m_connections);
}

/*! Creates a direct connection from the signal in the sender object to the method in the receiver object,
 *  invoking the given proxy function in between.
 */
bool QSignalProxy::proxyConnect(const QObject *sender, const char *signal, Function *proxy, const QObject *receiver, const char *method)
{
	// Strip number prefixes
	while (isdigit(*signal)) ++signal;
	while (isdigit(*method)) ++method;

	QByteArray sigProxyIn = proxy->signature_in();
	QByteArray sigProxyOut = proxy->signature_out();
	QByteArray sigSignal= QMetaObject::normalizedSignature(signal);
	QByteArray sigMethod = QMetaObject::normalizedSignature(method);

	if (!QMetaObject::checkConnectArgs(sigSignal, sigProxyIn)) {
		qWarning("QSignalProxy::connect(): Incompatible connection: %s to %s", sigSignal.data(), sigProxyIn.data());
		delete proxy;
		return false;
	}
	if (!QMetaObject::checkConnectArgs(sigProxyOut, sigMethod)) {
		qWarning("QSignalProxy::connect(): Incompatible connection: %s to %s", sigProxyOut.data(), sigMethod.data());
		delete proxy;
		return false;
	}

	// Determine signal and slot ids
	int signalId = sender->metaObject()->indexOfSignal(sigSignal);
	if (signalId == -1) {
		qWarning("QSignalProxy::connect(): No such signal: %s::%s", sender->metaObject()->className(), sigSignal.data());
		delete proxy;
		return false;
	}
	int slotId = receiver->metaObject()->indexOfSlot(sigMethod);
	if (slotId == -1) {
		qWarning("QSignalProxy::connect(): No such slot : %s::%s", receiver->metaObject()->className(), sigMethod.data());
		delete proxy;
		return false;
	}

	// Connect signal and register new connection
	if (!QMetaObject::connect(sender, signalId, this, metaObject()->methodCount() + 1 + m_connections.count())) {
		qWarning("QSignalProxy::connect(): Connecting %s::%s to %s failed\n", sender->metaObject()->className(), sigSignal.data(), sigProxyIn.data());
		delete proxy;
		return false;
	}
	m_connections += new Receiver(proxy, receiver, slotId);
	return true;
}


// Reimplemented from QOBJECT macro
const QMetaObject *QSignalProxy::metaObject() const
{
	return QObject::d_ptr->metaObject ? QObject::d_ptr->metaObject : &staticMetaObject;
}

// Reimplemented from QOBJECT macro
void *QSignalProxy::qt_metacast(const char *_clname)
{
    if (!_clname) return 0;
    if (!strcmp(_clname, qt_meta_stringdata_QSignalProxy))
        return static_cast<void*>(const_cast< QSignalProxy*>(this));
    return QObject::qt_metacast(_clname);
}

// Reimplemented from QOBJECT macro
int QSignalProxy::qt_metacall(QMetaObject::Call call, int id, void **args)
{
	id = QObject::qt_metacall(call, id, args);
	if (id == -1 || call != QMetaObject::InvokeMetaMethod || id > m_connections.count()) {
		return id;
	}

	Receiver *c = m_connections[id - 1];

	// Invoke proxy function
	void *result[2] = {0, 0};
	c->f->call(&result[1], args);

	// Invoke receiver slot
	const_cast<QObject *>(c->o)->qt_metacall(call, c->methodId, result);
	return -1;
}
